/**
 * Памет - Векторна база данни за бързо търсене
 *
 * Използва косинусно сходство за семантично търсене.
 * Оптимизирана за ниска консумация на ресурси чрез:
 * - Lazy loading на данни
 * - Ефективно кеширане
 * - Batch операции за embeddings
 */

import { randomUUID } from "node:crypto";
import type {
  ВекторноПредставяне,
  ДокументМетаданни,
  КонфигурацияНаПамет,
  РезултатОтТърсене,
  СтатистикаЗаИзползване,
  ТекстовСегмент,
} from "../models/types.js";

/** Конфигурация по подразбиране */
const ПОДРАЗБИРАНЕ: КонфигурацияНаПамет = {
  максРезултати: 10,
  прагНаСходство: 0.7,
  пътДоБаза: "./.fwm-data",
  моделЗаВектори: "auto",
  автоИндексиране: true,
  максДължинаСегмент: 512,
};

/** Интерфейс за embedding провайдър */
export interface EmbeddingПровайдър {
  вградиТекст(текст: string): Promise<number[]>;
  вградиПакет(текстове: string[]): Promise<number[][]>;
}

/** Запис за използване на сегмент */
interface ЗаписЗаИзползване {
  сегментИд: string;
  използванНа: Date;
  контекст?: string;
}

/**
 * Изчислява косинусно сходство между два вектора
 */
function косинусноСходство(а: number[], б: number[]): number {
  if (а.length !== б.length) return 0;

  let точковоПроизведение = 0;
  let нормаА = 0;
  let нормаБ = 0;

  for (let i = 0; i < а.length; i++) {
    точковоПроизведение += а[i] * б[i];
    нормаА += а[i] * а[i];
    нормаБ += б[i] * б[i];
  }

  const делител = Math.sqrt(нормаА) * Math.sqrt(нормаБ);
  return делител === 0 ? 0 : точковоПроизведение / делител;
}

/**
 * Създава Памет инстанция за управление на векторна база данни
 */
export function създайПамет(
  провайдър: EmbeddingПровайдър,
  конфиг: Partial<КонфигурацияНаПамет> = {},
) {
  const настройки: КонфигурацияНаПамет = { ...ПОДРАЗБИРАНЕ, ...конфиг };

  // In-memory съхранение (може да се замени с SQLite/sqlite-vec)
  const документи = new Map<string, ДокументМетаданни>();
  const сегменти = new Map<string, ТекстовСегмент>();
  const вектори = new Map<string, ВекторноПредставяне>();
  const използвания = new Map<string, ЗаписЗаИзползване[]>();

  // Кеш за скорошни embeddings
  const embeddingКеш = new Map<string, number[]>();
  const МАКС_КЕШ = 1000;

  /**
   * Генерира хеш за кеш ключ
   */
  function генерирайКешКлюч(текст: string): string {
    let хеш = 0;
    for (let i = 0; i < текст.length; i++) {
      хеш = (хеш << 5) - хеш + текст.charCodeAt(i);
      хеш |= 0;
    }
    return хеш.toString(36);
  }

  /**
   * Получава embedding с кеширане
   */
  async function получиEmbedding(текст: string): Promise<number[]> {
    const ключ = генерирайКешКлюч(текст);

    if (embeddingКеш.has(ключ)) {
      return embeddingКеш.get(ключ)!;
    }

    const вектор = await провайдър.вградиТекст(текст);

    // Управление на размера на кеша
    if (embeddingКеш.size >= МАКС_КЕШ) {
      const първиКлюч = embeddingКеш.keys().next().value;
      if (първиКлюч) embeddingКеш.delete(първиКлюч);
    }

    embeddingКеш.set(ключ, вектор);
    return вектор;
  }

  return {
    /**
     * Добавя документ в паметта
     */
    async добавиДокумент(
      метаданни: ДокументМетаданни,
      сегментиЗаДобавяне: ТекстовСегмент[],
    ): Promise<{ успех: boolean; добавени: number }> {
      документи.set(метаданни.идентификатор, метаданни);

      // Batch embedding за ефективност
      const текстове = сегментиЗаДобавяне.map((с) => с.съдържание);
      const embeddings = await провайдър.вградиПакет(текстове);

      let добавени = 0;

      for (let i = 0; i < сегментиЗаДобавяне.length; i++) {
        const сегмент = сегментиЗаДобавяне[i];
        сегменти.set(сегмент.идентификатор, сегмент);

        const векторноПредставяне: ВекторноПредставяне = {
          сегментИд: сегмент.идентификатор,
          вектор: embeddings[i],
          размерност: embeddings[i].length,
          модел: настройки.моделЗаВектори,
          генериранНа: new Date(),
        };

        вектори.set(сегмент.идентификатор, векторноПредставяне);
        добавени++;
      }

      return { успех: true, добавени };
    },

    /**
     * Търси подобни сегменти по текст
     */
    async търси(
      заявка: string,
      опции: { максРезултати?: number; прагНаСходство?: number } = {},
    ): Promise<РезултатОтТърсене[]> {
      const максРезултати = опции.максРезултати ?? настройки.максРезултати;
      const праг = опции.прагНаСходство ?? настройки.прагНаСходство;

      const заявкаВектор = await получиEmbedding(заявка);
      const резултати: РезултатОтТърсене[] = [];

      for (const [сегментИд, векторноПредставяне] of вектори) {
        const сходство = косинусноСходство(
          заявкаВектор,
          векторноПредставяне.вектор,
        );

        if (сходство >= праг) {
          const сегмент = сегменти.get(сегментИд);
          if (!сегмент) continue;

          const документ = документи.get(сегмент.документИд);
          if (!документ) continue;

          const записиЗаИзползване = използвания.get(сегментИд) || [];
          const използванПреди = записиЗаИзползване.length > 0;
          const последноИзползване = записиЗаИзползване.length > 0
            ? записиЗаИзползване[записиЗаИзползване.length - 1].използванНа
            : undefined;

          резултати.push({
            сегмент,
            сходство,
            документ,
            използванПреди,
            последноИзползване,
          });
        }
      }

      // Сортира по сходство (низходящо)
      резултати.sort((а, б) => б.сходство - а.сходство);

      return резултати.slice(0, максРезултати);
    },

    /**
     * Маркира сегмент като използван
     */
    маркирайКатоИзползван(сегментИд: string, контекст?: string): void {
      const записи = използвания.get(сегментИд) || [];
      записи.push({
        сегментИд,
        използванНа: new Date(),
        контекст,
      });
      използвания.set(сегментИд, записи);
    },

    /**
     * Проверява дали информация вече е използвана
     */
    еИзползвана(сегментИд: string): boolean {
      const записи = използвания.get(сегментИд);
      return записи !== undefined && записи.length > 0;
    },

    /**
     * Връща история на използване за сегмент
     */
    историяНаИзползване(сегментИд: string): ЗаписЗаИзползване[] {
      return използвания.get(сегментИд) || [];
    },

    /**
     * Премахва документ и свързаните сегменти
     */
    премахниДокумент(документИд: string): boolean {
      if (!документи.has(документИд)) return false;

      // Премахва свързаните сегменти
      for (const [сегментИд, сегмент] of сегменти) {
        if (сегмент.документИд === документИд) {
          сегменти.delete(сегментИд);
          вектори.delete(сегментИд);
          използвания.delete(сегментИд);
        }
      }

      документи.delete(документИд);
      return true;
    },

    /**
     * Връща документ по идентификатор
     */
    вземиДокумент(документИд: string): ДокументМетаданни | undefined {
      return документи.get(документИд);
    },

    /**
     * Връща всички документи
     */
    всичкиДокументи(): ДокументМетаданни[] {
      return Array.from(документи.values());
    },

    /**
     * Връща сегменти за документ
     */
    сегментиЗаДокумент(документИд: string): ТекстовСегмент[] {
      return Array.from(сегменти.values()).filter(
        (с) => с.документИд === документИд,
      );
    },

    /**
     * Връща статистика за паметта
     */
    статистика(): СтатистикаЗаИзползване {
      let използванаПамет = 0;

      // Приблизителна оценка на паметта
      for (const вектор of вектори.values()) {
        използванаПамет += вектор.вектор.length * 4; // 4 bytes per float
      }

      for (const сегмент of сегменти.values()) {
        използванаПамет += сегмент.съдържание.length * 2; // 2 bytes per char
      }

      return {
        общоДокументи: документи.size,
        общоСегменти: сегменти.size,
        използванаПамет: Math.round(използванаПамет / 1024 / 1024 * 100) / 100,
        бройТърсения: 0, // Може да се добави брояч
        последнаСинхронизация: new Date(),
      };
    },

    /**
     * Изчиства цялата памет
     */
    изчисти(): void {
      документи.clear();
      сегменти.clear();
      вектори.clear();
      използвания.clear();
      embeddingКеш.clear();
    },

    /**
     * Експортира данни за персистиране
     */
    експортирай(): {
      документи: ДокументМетаданни[];
      сегменти: ТекстовСегмент[];
      вектори: ВекторноПредставяне[];
    } {
      return {
        документи: Array.from(документи.values()),
        сегменти: Array.from(сегменти.values()),
        вектори: Array.from(вектори.values()),
      };
    },

    /**
     * Импортира данни от персистирано състояние
     */
    импортирай(данни: {
      документи: ДокументМетаданни[];
      сегменти: ТекстовСегмент[];
      вектори: ВекторноПредставяне[];
    }): void {
      for (const док of данни.документи) {
        документи.set(док.идентификатор, док);
      }
      for (const сег of данни.сегменти) {
        сегменти.set(сег.идентификатор, сег);
      }
      for (const век of данни.вектори) {
        вектори.set(век.сегментИд, век);
      }
    },
  };
}

export type Памет = ReturnType<typeof създайПамет>;
