/**
 * Анализатор - Модул за анализ на документи
 *
 * Координира процеса на обработка на документи:
 * - Определяне на тип и формат
 * - Извличане на съдържание
 * - Сегментиране и индексиране
 * - Организиране на сценарии
 */

import { randomUUID } from "node:crypto";
import type {
  ДокументМетаданни,
  ПоддържанФормат,
  РезултатОтКачване,
  РезултатОтТърсене,
  Сценарий,
  СъстояниеНаОбработка,
  ТипИзточник,
} from "../models/types.js";
import { създайПамет, type EmbeddingПровайдър, type Памет } from "./memory.js";
import { създайСегментатор, type Сегментатор } from "./segmentator.js";

/** Опции за създаване на анализатор */
export interface АнализаторОпции {
  /** Embedding провайдър */
  embeddingПровайдър: EmbeddingПровайдър;
  /** Максимална дължина на сегмент */
  максДължинаСегмент?: number;
  /** Автоматично индексиране */
  автоИндексиране?: boolean;
}

/** Резултат от анализ */
export interface РезултатОтАнализ {
  /** Успех на операцията */
  успех: boolean;
  /** Метаданни на документа */
  документ?: ДокументМетаданни;
  /** Брой сегменти */
  бройСегменти: number;
  /** Извлечени ключови думи */
  ключовиДуми: string[];
  /** Съобщение за грешка */
  грешка?: string;
  /** Време за обработка в ms */
  времеЗаОбработка: number;
}

/** Контекст за обработка */
interface КонтекстЗаОбработка {
  документИд: string;
  състояние: СъстояниеНаОбработка;
  началоНаОбработка: Date;
  прогрес: number;
}

/**
 * Определя формат на файл по разширение
 */
function определиФормат(имеНаФайл: string): ПоддържанФормат {
  const разширение = имеНаФайл.split(".").pop()?.toLowerCase();

  switch (разширение) {
    case "pdf":
      return "pdf";
    case "json":
      return "json";
    case "jpg":
    case "jpeg":
    case "png":
    case "gif":
    case "webp":
    case "bmp":
      return "image";
    default:
      return "text";
  }
}

/**
 * Извлича текст от JSON съдържание
 */
function извлечиТекстОтJSON(съдържание: string): string {
  try {
    const данни = JSON.parse(съдържание);
    return извлечиТекстОтОбект(данни);
  } catch {
    return съдържание;
  }
}

/**
 * Рекурсивно извлича текст от обект
 */
function извлечиТекстОтОбект(обект: unknown, дълбочина = 0): string {
  if (дълбочина > 10) return "";

  if (typeof обект === "string") return обект;
  if (typeof обект === "number") return String(обект);
  if (typeof обект === "boolean") return "";
  if (обект === null || обект === undefined) return "";

  if (Array.isArray(обект)) {
    return обект
      .map((елемент) => извлечиТекстОтОбект(елемент, дълбочина + 1))
      .filter((т) => т.length > 0)
      .join("\n");
  }

  if (typeof обект === "object") {
    const частиТекст: string[] = [];

    for (const [ключ, стойност] of Object.entries(обект)) {
      const текстНаСтойност = извлечиТекстОтОбект(стойност, дълбочина + 1);
      if (текстНаСтойност.length > 0) {
        частиТекст.push(`${ключ}: ${текстНаСтойност}`);
      }
    }

    return частиТекст.join("\n");
  }

  return "";
}

/**
 * Създава Анализатор инстанция
 */
export function създайАнализатор(опции: АнализаторОпции) {
  const памет = създайПамет(опции.embeddingПровайдър, {
    максДължинаСегмент: опции.максДължинаСегмент ?? 512,
    автоИндексиране: опции.автоИндексиране ?? true,
  });

  const сегментатор = създайСегментатор({
    максДължина: опции.максДължинаСегмент ?? 512,
  });

  // Активни обработки
  const обработки = new Map<string, КонтекстЗаОбработка>();

  // Сценарии
  const сценарии = new Map<string, Сценарий>();

  return {
    /**
     * Анализира текстово съдържание
     */
    async анализирайТекст(
      текст: string,
      имеНаФайл: string,
      източник: ТипИзточник = "текст",
    ): Promise<РезултатОтАнализ> {
      const началоВреме = Date.now();
      const документИд = randomUUID();

      обработки.set(документИд, {
        документИд,
        състояние: "обработка",
        началоНаОбработка: new Date(),
        прогрес: 0,
      });

      try {
        const формат = определиФормат(имеНаФайл);

        // Извлича текст според формата
        let обработенТекст = текст;
        if (формат === "json") {
          обработенТекст = извлечиТекстОтJSON(текст);
        }

        // Сегментира текста
        const сегменти = сегментатор.сегментирай(обработенТекст, документИд);
        const обединениСегменти = сегментатор.обединиМалки(сегменти);

        // Извлича ключови думи
        const всичкиКлючовиДуми = new Set<string>();
        for (const сегмент of обединениСегменти) {
          const думи = сегментатор.извлечиКлючовиДуми(сегмент);
          думи.forEach((д) => всичкиКлючовиДуми.add(д));
        }

        // Създава метаданни
        const метаданни: ДокументМетаданни = {
          идентификатор: документИд,
          имеНаФайл,
          формат,
          размер: текст.length,
          създаденНа: new Date(),
          променен: new Date(),
          източник,
          тагове: Array.from(всичкиКлючовиДуми).slice(0, 10),
        };

        // Добавя в паметта
        await памет.добавиДокумент(метаданни, обединениСегменти);

        обработки.set(документИд, {
          ...обработки.get(документИд)!,
          състояние: "завършено",
          прогрес: 100,
        });

        return {
          успех: true,
          документ: метаданни,
          бройСегменти: обединениСегменти.length,
          ключовиДуми: Array.from(всичкиКлючовиДуми),
          времеЗаОбработка: Date.now() - началоВреме,
        };
      } catch (грешка) {
        обработки.set(документИд, {
          ...обработки.get(документИд)!,
          състояние: "грешка",
        });

        return {
          успех: false,
          бройСегменти: 0,
          ключовиДуми: [],
          грешка: грешка instanceof Error ? грешка.message : String(грешка),
          времеЗаОбработка: Date.now() - началоВреме,
        };
      }
    },

    /**
     * Търси в паметта
     */
    async търси(
      заявка: string,
      опции?: { максРезултати?: number },
    ): Promise<РезултатОтТърсене[]> {
      return памет.търси(заявка, опции);
    },

    /**
     * Търси и маркира като използвано
     */
    async търсиИИзползвай(
      заявка: string,
      контекст?: string,
    ): Promise<РезултатОтТърсене[]> {
      const резултати = await памет.търси(заявка, { максРезултати: 5 });

      for (const резултат of резултати) {
        памет.маркирайКатоИзползван(резултат.сегмент.идентификатор, контекст);
      }

      return резултати;
    },

    /**
     * Създава нов сценарий
     */
    създайСценарий(име: string, описание: string): Сценарий {
      const сценарий: Сценарий = {
        идентификатор: randomUUID(),
        име,
        описание,
        документи: [],
        създаденНа: new Date(),
        активен: true,
      };

      сценарии.set(сценарий.идентификатор, сценарий);
      return сценарий;
    },

    /**
     * Добавя документ към сценарий
     */
    добавиКъмСценарий(сценарийИд: string, документИд: string): boolean {
      const сценарий = сценарии.get(сценарийИд);
      if (!сценарий) return false;

      if (!сценарий.документи.includes(документИд)) {
        сценарий.документи.push(документИд);
      }

      return true;
    },

    /**
     * Връща всички сценарии
     */
    всичкиСценарии(): Сценарий[] {
      return Array.from(сценарии.values());
    },

    /**
     * Връща сценарий по идентификатор
     */
    вземиСценарий(идентификатор: string): Сценарий | undefined {
      return сценарии.get(идентификатор);
    },

    /**
     * Организира документи по сценарии автоматично
     */
    async автоОрганизирай(
      документИд: string,
      прагЗаСходство = 0.8,
    ): Promise<string[]> {
      const документ = памет.вземиДокумент(документИд);
      if (!документ) return [];

      const предложениСценарии: string[] = [];

      // Търси подобни документи за всеки сценарий
      for (const [сценарийИд, сценарий] of сценарии) {
        if (сценарий.документи.length === 0) continue;

        // Проверява сходство с документи в сценария
        const сегменти = памет.сегментиЗаДокумент(документИд);
        if (сегменти.length === 0) continue;

        const резултати = await памет.търси(сегменти[0].съдържание, {
          максРезултати: 3,
          прагНаСходство: прагЗаСходство,
        });

        const имаСходство = резултати.some((р) =>
          сценарий.документи.includes(р.документ.идентификатор)
        );

        if (имаСходство) {
          предложениСценарии.push(сценарийИд);
        }
      }

      return предложениСценарии;
    },

    /**
     * Връща статистика
     */
    статистика() {
      const паметСтат = памет.статистика();
      const сегментаторСтат = {
        общоСценарии: сценарии.size,
        активниСценарии: Array.from(сценарии.values()).filter((с) => с.активен)
          .length,
      };

      return {
        ...паметСтат,
        ...сегментаторСтат,
        активниОбработки: Array.from(обработки.values()).filter(
          (о) => о.състояние === "обработка",
        ).length,
      };
    },

    /**
     * Достъп до памет модула
     */
    памет,

    /**
     * Достъп до сегментатор модула
     */
    сегментатор,

    /**
     * Премахва документ
     */
    премахниДокумент(документИд: string): boolean {
      // Премахва от сценарии
      for (const сценарий of сценарии.values()) {
        const индекс = сценарий.документи.indexOf(документИд);
        if (индекс !== -1) {
          сценарий.документи.splice(индекс, 1);
        }
      }

      return памет.премахниДокумент(документИд);
    },

    /**
     * Изчиства всичко
     */
    изчисти(): void {
      памет.изчисти();
      сценарии.clear();
      обработки.clear();
    },
  };
}

export type Анализатор = ReturnType<typeof създайАнализатор>;
