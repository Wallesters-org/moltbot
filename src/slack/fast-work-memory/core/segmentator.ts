/**
 * Сегментатор - Модул за разделяне на текст на смислови части
 *
 * Оптимизиран за ниска консумация на CPU и памет.
 * Поддържа различни типове съдържание: заглавия, параграфи, списъци, таблици, код.
 */

import { randomUUID } from "node:crypto";
import type { ТекстовСегмент } from "../models/types.js";

/** Конфигурация за сегментиране */
export interface СегментацияКонфиг {
  /** Максимална дължина на сегмент в символи */
  максДължина: number;
  /** Минимална дължина на сегмент */
  минДължина: number;
  /** Припокриване между сегменти */
  припокриване: number;
  /** Запазване на структура */
  запазиСтруктура: boolean;
}

/** Конфигурация по подразбиране */
const ПОДРАЗБИРАНЕ: СегментацияКонфиг = {
  максДължина: 512,
  минДължина: 50,
  припокриване: 50,
  запазиСтруктура: true,
};

/** Регулярни изрази за разпознаване на структура */
const ШАБЛОНИ = {
  заглавие: /^#{1,6}\s+.+$|^[A-ZА-Я][A-ZА-Я\s]{2,}$/m,
  списък: /^[\s]*[-*•]\s+.+$|^[\s]*\d+[.)]\s+.+$/m,
  код: /^```[\s\S]*?```$|^`[^`]+`$/m,
  таблица: /^\|.+\|$/m,
  параграф: /^.{20,}$/m,
};

/**
 * Определя типа на текстов блок
 */
function определиТип(текст: string): ТекстовСегмент["тип"] {
  const чист = текст.trim();

  if (ШАБЛОНИ.код.test(чист)) return "код";
  if (ШАБЛОНИ.таблица.test(чист)) return "таблица";
  if (ШАБЛОНИ.заглавие.test(чист)) return "заглавие";
  if (ШАБЛОНИ.списък.test(чист)) return "списък";
  return "параграф";
}

/**
 * Разделя текст на параграфи по празни редове
 */
function разделиНаПараграфи(текст: string): string[] {
  return текст
    .split(/\n\s*\n/)
    .map((п) => п.trim())
    .filter((п) => п.length > 0);
}

/**
 * Разделя дълъг текст на по-малки части с припокриване
 */
function разделиДългТекст(
  текст: string,
  максДължина: number,
  припокриване: number,
): string[] {
  const части: string[] = [];
  let начало = 0;

  while (начало < текст.length) {
    let край = начало + максДължина;

    // Търси естествена граница (точка, запетая, нов ред)
    if (край < текст.length) {
      const подтекст = текст.slice(начало, край);
      const последнаТочка = Math.max(
        подтекст.lastIndexOf("."),
        подтекст.lastIndexOf("!"),
        подтекст.lastIndexOf("?"),
        подтекст.lastIndexOf("\n"),
      );

      if (последнаТочка > максДължина * 0.5) {
        край = начало + последнаТочка + 1;
      }
    }

    части.push(текст.slice(начало, край).trim());
    начало = край - припокриване;

    // Избягва безкраен цикъл
    if (начало >= текст.length - припокриване) {
      break;
    }
  }

  return части.filter((ч) => ч.length > 0);
}

/**
 * Изчислява ниво на вложеност базирано на структура
 */
function изчислиНиво(текст: string, индекс: number): number {
  const редове = текст.slice(0, индекс).split("\n");
  let ниво = 0;

  for (const ред of редове) {
    if (/^#{1,6}\s+/.test(ред)) {
      ниво = ред.match(/^#+/)![0].length;
    }
  }

  return ниво;
}

/**
 * Създава Сегментатор инстанция
 */
export function създайСегментатор(конфиг: Partial<СегментацияКонфиг> = {}) {
  const настройки: СегментацияКонфиг = { ...ПОДРАЗБИРАНЕ, ...конфиг };

  return {
    /**
     * Сегментира текст на смислови части
     */
    сегментирай(текст: string, документИд: string): ТекстовСегмент[] {
      if (!текст || текст.trim().length === 0) {
        return [];
      }

      const сегменти: ТекстовСегмент[] = [];
      const параграфи = разделиНаПараграфи(текст);
      let позиция = 0;

      for (const параграф of параграфи) {
        const начало = текст.indexOf(параграф, позиция);
        const тип = определиТип(параграф);
        const ниво = изчислиНиво(текст, начало);

        // Разделя дълги параграфи
        if (параграф.length > настройки.максДължина) {
          const части = разделиДългТекст(
            параграф,
            настройки.максДължина,
            настройки.припокриване,
          );

          let частПозиция = 0;
          for (const част of части) {
            const частНачало = параграф.indexOf(част, частПозиция);

            сегменти.push({
              идентификатор: randomUUID(),
              документИд,
              съдържание: част,
              началнаПозиция: начало + частНачало,
              крайнаПозиция: начало + частНачало + част.length,
              ниво,
              тип,
            });

            частПозиция = частНачало + част.length - настройки.припокриване;
          }
        } else if (параграф.length >= настройки.минДължина) {
          сегменти.push({
            идентификатор: randomUUID(),
            документИд,
            съдържание: параграф,
            началнаПозиция: начало,
            крайнаПозиция: начало + параграф.length,
            ниво,
            тип,
          });
        }

        позиция = начало + параграф.length;
      }

      return сегменти;
    },

    /**
     * Обединява малки съседни сегменти
     */
    обединиМалки(сегменти: ТекстовСегмент[]): ТекстовСегмент[] {
      if (сегменти.length <= 1) return сегменти;

      const резултат: ТекстовСегмент[] = [];
      let буфер: ТекстовСегмент | null = null;

      for (const сегмент of сегменти) {
        if (!буфер) {
          буфер = { ...сегмент };
          continue;
        }

        const общаДължина = буфер.съдържание.length + сегмент.съдържание.length;

        if (общаДължина <= настройки.максДължина && буфер.тип === сегмент.тип) {
          буфер.съдържание += "\n\n" + сегмент.съдържание;
          буфер.крайнаПозиция = сегмент.крайнаПозиция;
        } else {
          резултат.push(буфер);
          буфер = { ...сегмент };
        }
      }

      if (буфер) {
        резултат.push(буфер);
      }

      return резултат;
    },

    /**
     * Извлича ключови думи от сегмент
     */
    извлечиКлючовиДуми(сегмент: ТекстовСегмент): string[] {
      const текст = сегмент.съдържание.toLowerCase();

      // Премахва специални символи
      const чист = текст.replace(/[^\p{L}\p{N}\s]/gu, " ");

      // Разделя на думи
      const думи = чист.split(/\s+/).filter((д) => д.length > 3);

      // Премахва стоп думи (български и английски)
      const стопДуми = new Set([
        "това",
        "този",
        "тази",
        "тези",
        "като",
        "обаче",
        "след",
        "преди",
        "когато",
        "защото",
        "which",
        "where",
        "there",
        "their",
        "would",
        "could",
        "should",
        "about",
        "with",
        "from",
        "that",
        "this",
        "have",
        "been",
        "were",
        "will",
      ]);

      const уникални = [...new Set(думи)].filter((д) => !стопДуми.has(д));

      return уникални.slice(0, 10);
    },

    /**
     * Връща статистика за сегментация
     */
    статистика(сегменти: ТекстовСегмент[]) {
      const поТип = сегменти.reduce(
        (акум, с) => {
          акум[с.тип] = (акум[с.тип] || 0) + 1;
          return акум;
        },
        {} as Record<string, number>,
      );

      const общоСимволи = сегменти.reduce(
        (с, сег) => с + сег.съдържание.length,
        0,
      );

      return {
        общоСегменти: сегменти.length,
        общоСимволи,
        средноНаСегмент: Math.round(общоСимволи / сегменти.length) || 0,
        разпределениеПоТип: поТип,
      };
    },
  };
}

export type Сегментатор = ReturnType<typeof създайСегментатор>;
