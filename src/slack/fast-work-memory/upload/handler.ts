/**
 * Обработчик на качвания - Модул за работа с файлове
 *
 * Поддържа:
 * - PDF документи (с извличане на текст)
 * - JSON файлове (с парсване на структура)
 * - Изображения (с OCR интеграция)
 * - Текстови файлове
 */

import { readFile, stat } from "node:fs/promises";
import { extname, basename } from "node:path";
import { randomUUID } from "node:crypto";
import type {
  ОпцииЗаКачване,
  ПоддържанФормат,
  РезултатОтКачване,
  ТипИзточник,
} from "../models/types.js";
import { създайСкенер, type Скенер } from "../ocr/scanner.js";
import { създайАнализатор, type Анализатор } from "../core/analyzer.js";
import type { EmbeddingПровайдър } from "../core/memory.js";

/** Конфигурация за обработчик */
export interface ОбработчикКонфигурация {
  /** Максимален размер на файл в байтове */
  максРазмер: number;
  /** Разрешени формати */
  разрешениФормати: ПоддържанФормат[];
  /** Автоматично OCR за изображения */
  автоOCR: boolean;
  /** Временна директория */
  временнаДиректория: string;
}

/** Конфигурация по подразбиране */
const ПОДРАЗБИРАНЕ: ОбработчикКонфигурация = {
  максРазмер: 50 * 1024 * 1024, // 50 MB
  разрешениФормати: ["pdf", "json", "image", "text"],
  автоOCR: true,
  временнаДиректория: "/tmp/fwm-uploads",
};

/** Поддържани MIME типове */
const MIME_КЪМ_ФОРМАТ: Record<string, ПоддържанФормат> = {
  "application/pdf": "pdf",
  "application/json": "json",
  "text/json": "json",
  "image/jpeg": "image",
  "image/png": "image",
  "image/gif": "image",
  "image/webp": "image",
  "image/bmp": "image",
  "text/plain": "text",
  "text/markdown": "text",
  "text/html": "text",
};

/** Разширения към формати */
const РАЗШИРЕНИЕ_КЪМ_ФОРМАТ: Record<string, ПоддържанФормат> = {
  ".pdf": "pdf",
  ".json": "json",
  ".jpg": "image",
  ".jpeg": "image",
  ".png": "image",
  ".gif": "image",
  ".webp": "image",
  ".bmp": "image",
  ".txt": "text",
  ".md": "text",
  ".html": "text",
  ".htm": "text",
};

/**
 * Определя формат по MIME тип или разширение
 */
function определиФормат(
  имеНаФайл: string,
  mimeТип?: string,
): ПоддържанФормат | null {
  // Първо опитва по MIME тип
  if (mimeТип && MIME_КЪМ_ФОРМАТ[mimeТип]) {
    return MIME_КЪМ_ФОРМАТ[mimeТип];
  }

  // След това по разширение
  const разширение = extname(имеНаФайл).toLowerCase();
  if (РАЗШИРЕНИЕ_КЪМ_ФОРМАТ[разширение]) {
    return РАЗШИРЕНИЕ_КЪМ_ФОРМАТ[разширение];
  }

  return null;
}

/**
 * Валидира файл за качване
 */
function валидирайФайл(
  размер: number,
  формат: ПоддържанФормат | null,
  конфиг: ОбработчикКонфигурация,
): { валиден: boolean; грешка?: string } {
  if (размер > конфиг.максРазмер) {
    const максMB = Math.round(конфиг.максРазмер / 1024 / 1024);
    return {
      валиден: false,
      грешка: `Файлът надвишава максималния размер от ${максMB} MB`,
    };
  }

  if (!формат) {
    return { валиден: false, грешка: "Неподдържан формат на файл" };
  }

  if (!конфиг.разрешениФормати.includes(формат)) {
    return {
      валиден: false,
      грешка: `Форматът ${формат} не е разрешен`,
    };
  }

  return { валиден: true };
}

/**
 * Извлича текст от PDF (опростена имплементация)
 * В продукция се заменя с pdf-parse или подобна библиотека
 */
async function извлечиТекстОтPDF(буфер: Buffer): Promise<string> {
  // Опростено извличане на текст от PDF
  // Търси текстови стрингове между скоби
  const текст = буфер.toString("latin1");
  const съвпадения: string[] = [];

  // Търси BT...ET блокове (text objects)
  const btРегекс = /BT[\s\S]*?ET/g;
  let съвпадение;

  while ((съвпадение = btРегекс.exec(текст)) !== null) {
    // Извлича текст между скоби
    const tjРегекс = /\(([^)]+)\)/g;
    let tjСъвп;
    while ((tjСъвп = tjРегекс.exec(съвпадение[0])) !== null) {
      if (tjСъвп[1].length > 0) {
        съвпадения.push(tjСъвп[1]);
      }
    }
  }

  return съвпадения.join(" ").trim();
}

/**
 * Създава Обработчик инстанция
 */
export function създайОбработчик(
  анализатор: Анализатор,
  скенер: Скенер,
  конфиг: Partial<ОбработчикКонфигурация> = {},
) {
  const настройки: ОбработчикКонфигурация = { ...ПОДРАЗБИРАНЕ, ...конфиг };

  // Статистика
  let общоКачвания = 0;
  let успешниКачвания = 0;
  let общоБайтове = 0;

  return {
    /**
     * Качва файл от път
     */
    async качиОтПът(
      път: string,
      опции: Partial<ОпцииЗаКачване> = {},
    ): Promise<РезултатОтКачване> {
      общоКачвания++;

      try {
        const статистика = await stat(път);
        const имеНаФайл = basename(път);
        const формат = определиФормат(имеНаФайл);

        const валидация = валидирайФайл(статистика.size, формат, настройки);
        if (!валидация.валиден) {
          return {
            успех: false,
            грешка: валидация.грешка,
            бройСегменти: 0,
          };
        }

        const буфер = await readFile(път);
        return this.качиБуфер(буфер, имеНаФайл, опции);
      } catch (грешка) {
        return {
          успех: false,
          грешка: грешка instanceof Error ? грешка.message : String(грешка),
          бройСегменти: 0,
        };
      }
    },

    /**
     * Качва файл от буфер
     */
    async качиБуфер(
      буфер: Buffer,
      имеНаФайл: string,
      опции: Partial<ОпцииЗаКачване> = {},
    ): Promise<РезултатОтКачване> {
      общоКачвания++;

      const формат = определиФормат(имеНаФайл);
      const валидация = валидирайФайл(буфер.length, формат, настройки);

      if (!валидация.валиден) {
        return {
          успех: false,
          грешка: валидация.грешка,
          бройСегменти: 0,
        };
      }

      try {
        let текст: string;
        const източник: ТипИзточник = опции.източник ?? "качване";

        switch (формат) {
          case "pdf":
            текст = await извлечиТекстОтPDF(буфер);
            break;

          case "json":
            текст = буфер.toString("utf-8");
            break;

          case "image":
            if (опции.автоOCR ?? настройки.автоOCR) {
              const ocrРезултат = await скенер.сканирай(буфер);
              текст = ocrРезултат.текст;
            } else {
              текст = "";
            }
            break;

          case "text":
          default:
            текст = буфер.toString("utf-8");
        }

        if (текст.trim().length === 0) {
          return {
            успех: false,
            грешка: "Не беше извлечен текст от файла",
            бройСегменти: 0,
          };
        }

        const резултат = await анализатор.анализирайТекст(
          текст,
          имеНаФайл,
          източник,
        );

        if (резултат.успех) {
          успешниКачвания++;
          общоБайтове += буфер.length;
        }

        return {
          успех: резултат.успех,
          документ: резултат.документ,
          грешка: резултат.грешка,
          бройСегменти: резултат.бройСегменти,
        };
      } catch (грешка) {
        return {
          успех: false,
          грешка: грешка instanceof Error ? грешка.message : String(грешка),
          бройСегменти: 0,
        };
      }
    },

    /**
     * Качва от URL
     */
    async качиОтURL(
      url: string,
      опции: Partial<ОпцииЗаКачване> = {},
    ): Promise<РезултатОтКачване> {
      общоКачвания++;

      try {
        const отговор = await fetch(url);
        if (!отговор.ok) {
          return {
            успех: false,
            грешка: `Грешка при изтегляне: ${отговор.status}`,
            бройСегменти: 0,
          };
        }

        const contentType = отговор.headers.get("content-type") || "";
        const urlПът = new URL(url).pathname;
        const имеНаФайл = basename(urlПът) || "downloaded-file";

        const буфер = Buffer.from(await отговор.arrayBuffer());

        return this.качиБуфер(буфер, имеНаФайл, {
          ...опции,
          източник: опции.източник ?? "качване",
        });
      } catch (грешка) {
        return {
          успех: false,
          грешка: грешка instanceof Error ? грешка.message : String(грешка),
          бройСегменти: 0,
        };
      }
    },

    /**
     * Качва текст директно
     */
    async качиТекст(
      текст: string,
      име: string,
      опции: Partial<ОпцииЗаКачване> = {},
    ): Promise<РезултатОтКачване> {
      общоКачвания++;

      if (текст.trim().length === 0) {
        return {
          успех: false,
          грешка: "Празен текст",
          бройСегменти: 0,
        };
      }

      try {
        const резултат = await анализатор.анализирайТекст(
          текст,
          име,
          опции.източник ?? "текст",
        );

        if (резултат.успех) {
          успешниКачвания++;
          общоБайтове += текст.length;
        }

        return {
          успех: резултат.успех,
          документ: резултат.документ,
          грешка: резултат.грешка,
          бройСегменти: резултат.бройСегменти,
        };
      } catch (грешка) {
        return {
          успех: false,
          грешка: грешка instanceof Error ? грешка.message : String(грешка),
          бройСегменти: 0,
        };
      }
    },

    /**
     * Качва JSON обект
     */
    async качиJSON(
      данни: unknown,
      име: string,
      опции: Partial<ОпцииЗаКачване> = {},
    ): Promise<РезултатОтКачване> {
      const текст = JSON.stringify(данни, null, 2);
      return this.качиТекст(текст, име.endsWith(".json") ? име : `${име}.json`, {
        ...опции,
        източник: опции.източник ?? "качване",
      });
    },

    /**
     * Връща поддържани формати
     */
    поддържаниФормати(): ПоддържанФормат[] {
      return [...настройки.разрешениФормати];
    },

    /**
     * Връща максимален размер
     */
    максРазмер(): number {
      return настройки.максРазмер;
    },

    /**
     * Връща статистика
     */
    статистика() {
      return {
        общоКачвания,
        успешниКачвания,
        успеваемост:
          общоКачвания > 0
            ? Math.round((успешниКачвания / общоКачвания) * 100)
            : 0,
        общоБайтове,
        общоMB: Math.round((общоБайтове / 1024 / 1024) * 100) / 100,
      };
    },

    /**
     * Нулира статистиката
     */
    нулирайСтатистика(): void {
      общоКачвания = 0;
      успешниКачвания = 0;
      общоБайтове = 0;
    },
  };
}

export type Обработчик = ReturnType<typeof създайОбработчик>;

/**
 * Създава пълен стек за обработка на качвания
 */
export function създайПълнаСистема(embeddingПровайдър: EmbeddingПровайдър) {
  const анализатор = създайАнализатор({ embeddingПровайдър });
  const скенер = създайСкенер();
  const обработчик = създайОбработчик(анализатор, скенер);

  return {
    анализатор,
    скенер,
    обработчик,
  };
}
